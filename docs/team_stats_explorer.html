<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Team Statistics Explorer — Universal Win% Correlations</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    :root {
      --red: #ef4444;
      --blue: #0ea5e9;
      --grid: #e8eaed;
      --axis: #9aa0a6;
      --text: #222;
    }
    body { margin: 16px; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; color: var(--text); background: #f7f7f7; }
    .container { max-width: 1200px; margin: 0 auto; background: #fff; border: 1px solid #e5e5e5; border-radius: 10px; padding: 12px 16px 22px; box-shadow: 0 1px 3px rgba(0,0,0,.06); }
    h1 { margin: 0 0 10px; font-size: 22px; }
    .subtitle { color: #666; font-size: 13px; margin: 4px 0 12px; }
    .panel { margin: 12px 0 14px; border: 1px solid #e5e5e5; border-radius: 10px; overflow: hidden; background: #fff; }
    .panel > summary { padding: 10px 14px; background: #f5f7fa; border-bottom: 1px solid #ebeff5; font-weight: 600; cursor: pointer; user-select: none; list-style: none; }
    .panel[open] > summary { border-bottom-color: #e6eaf0; }
    .chart-wrap { padding: 8px 8px 0; }
    .legend { display: flex; align-items: center; gap: 16px; color: #555; font-size: 12px; padding: 0 10px 10px; }
    .swatch { display: inline-block; width: 12px; height: 12px; border-radius: 2px; margin-right: 6px; vertical-align: middle; }
    .avg { background: repeating-linear-gradient(90deg, #bbb, #bbb 2px, transparent 2px, transparent 6px); border: 1px solid #bbb; }
    .red { background: var(--red); opacity: .5; }
    .blue { background: var(--blue); opacity: .5; }
    .tooltip { position: absolute; pointer-events: none; background: rgba(0,0,0,.78); color: #fff; padding: 6px 8px; border-radius: 6px; font-size: 12px; z-index: 10; }
    .correlation-badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; }
    .corr-strong { background: #dcfce7; color: #166534; }
    .corr-moderate { background: #fef3c7; color: #854d0e; }
    .corr-weak { background: #fee2e2; color: #991b1b; }
    .help-icon { display: inline-block; width: 16px; height: 16px; border-radius: 50%; background: #3b82f6; color: white; text-align: center; line-height: 16px; font-size: 11px; font-weight: bold; margin-left: 8px; cursor: help; vertical-align: middle; }
    .metric-tooltip { position: absolute; pointer-events: none; background: rgba(30,64,175,.95); color: #fff; padding: 8px 12px; border-radius: 6px; font-size: 12px; z-index: 100; max-width: 350px; line-height: 1.5; box-shadow: 0 4px 6px rgba(0,0,0,.3); }
  </style>
  <script>
    async function tryCsv(paths) {
      let lastErr;
      for (const p of paths) {
        try { return await d3.csv(p, d3.autoType); } catch (e) { lastErr = e; }
      }
      throw lastErr || new Error('Unable to load CSV: ' + paths.join(', '));
    }

    function toPct(x) { return d3.format('.1%')(x); }
    function fmt2(x) { return d3.format('.2f')(x); }
    function fmt3(x) { return d3.format('.3f')(x); }

    function regression(points) {
      let n = 0, sx = 0, sy = 0, sxy = 0, sxx = 0, syy = 0;
      for (const [x0, y0] of points) {
        const x = +x0, y = +y0;
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        n++; sx += x; sy += y; sxy += x*y; sxx += x*x; syy += y*y;
      }
      if (n < 2) return { m: 0, b: sy / (n || 1), r2: 0 };
      const denom = n * sxx - sx * sx;
      const m = denom !== 0 ? (n * sxy - sx * sy) / denom : 0;
      const b = (sy - m * sx) / n;
      
      const ssr = points.reduce((sum, [x0, y0]) => {
        const x = +x0, y = +y0;
        if (!Number.isFinite(x) || !Number.isFinite(y)) return sum;
        return sum + Math.pow(y - (m * x + b), 2);
      }, 0);
      const sst = syy - (sy * sy) / n;
      const r2 = sst !== 0 ? Math.max(0, 1 - ssr / sst) : 0;
      
      return { m, b, r2 };
    }

    const METRICS = [
      { key: 'pass_yds_per_att', label: 'Pass Yards per Attempt', format: fmt2, higherBetter: true, help: 'Средние ярды за попытку паса. Измеряет эффективность пасовой игры - чем выше, тем лучше качество передач.' },
      { key: 'rush_yds_per_att', label: 'Rush Yards per Attempt', format: fmt2, higherBetter: true, help: 'Средние ярды за вынос. Показывает эффективность беговой игры и качество линии нападения.' },
      { key: 'qb_rating', label: 'QB Rating', format: fmt2, higherBetter: true, help: 'Комплексный рейтинг QB (0-158). Учитывает completion%, ярды, TD и INT. Выше 100 = отлично, ниже 80 = плохо.' },
      { key: 'pass_int_pct', label: 'Interception Rate (%)', format: fmt2, higherBetter: false, help: 'Процент перехватов от попыток передач. Низкий процент = хорошая защита мяча, высокий = рискованные решения.' },
      { key: 'sack_rate', label: 'Sack Rate (%)', format: fmt2, higherBetter: false, help: 'Процент сэков от (попытки + сэки). Измеряет качество защиты линии нападения и мобильность QB.' },
      { key: 'turnover_diff', label: 'Turnover Differential', format: fmt2, higherBetter: true, help: 'Разница между отборами и отдачами мяча. Самый сильный предсказатель побед - положительный diff = больше побед.' },
      { key: 'td_per_play', label: 'TD per Play', format: fmt3, higherBetter: true, help: 'Тачдауны на розыгрыш. Измеряет эффективность красной зоны - способность финишировать драйвы TD вместо FG.' },
      { key: 'yds_per_play', label: 'Yards per Play', format: fmt2, higherBetter: true, help: 'Средние ярды за розыгрыш (пас + бег). Общая эффективность нападения - 5.5+ = хорошо, 6.0+ = отлично.' },
      { key: 'def_sacks_per_game', label: 'Defensive Sacks per Game', format: fmt2, higherBetter: true, help: 'Сэки защиты за игру. Показывает давление на QB соперника - 2.5+ = хороший pass rush, 3.0+ = отличный.' },
      { key: 'def_ints_per_game', label: 'Defensive INTs per Game', format: fmt2, higherBetter: true, help: 'Перехваты защиты за игру. Создание турноверов - ключ к победам. 1.0+ = хорошо, 1.5+ = elite defense.' },
      { key: 'pass_ints_per_game', label: 'INTs Thrown per Game', format: fmt2, higherBetter: false, help: 'Отданные перехваты за игру. Низкий показатель = хорошая защита мяча. <1.0 = хорошо, <0.7 = отлично.' },
      { key: 'sacks_allowed_per_game', label: 'Sacks Allowed per Game', format: fmt2, higherBetter: false, help: 'Полученные сэки за игру. Измеряет качество защиты O-line. <2.0 = хорошо, <1.5 = elite protection.' },
      { key: 'punts_per_game', label: 'Punts per Game', format: fmt2, higherBetter: false, help: 'Панты за игру. Низкий показатель = эффективное нападение с sustained drives. <4.0 = хорошо, <3.5 = отлично.' },
      { key: 'explosive_plays_per_game', label: '20+ Yard Plays per Game', format: fmt2, higherBetter: true, help: 'Розыгрыши 20+ ярдов за игру. Взрывные моменты поддерживают драйвы. 5+ = хорошо, 7+ = elite playmakers.' },
      { key: 'rush_broken_tackle_rate', label: 'Broken Tackles per Rush', format: fmt3, higherBetter: true, help: 'Процент сломанных захватов при выносе. Измеряет силу и ловкость RB. 0.10+ = хорошо, 0.15+ = elite power.' },
      { key: 'rush_yac_pct', label: 'Rush YAC %', format: fmt2, higherBetter: true, help: 'Процент ярдов после контакта при беге. Показывает физическую игру RB. 30%+ = хорошо, 35%+ = мощный runner.' },
      { key: 'rec_yac_pct', label: 'Receiving YAC %', format: fmt2, higherBetter: true, help: 'Процент ярдов после приёма (YAC). Способность приёмников создавать ярды после catch. 40%+ = динамичные WR.' },
      { key: 'pass_comp_pct', label: 'Completion %', format: fmt2, higherBetter: true, help: 'Процент завершённых передач. Точность QB и схема offense. 65%+ = хорошо, 70%+ = elite accuracy.' },
      { key: 'pass_td_pct', label: 'TD Rate (%)', format: fmt2, higherBetter: true, help: 'Процент тачдаунов от попыток передач. Эффективность красной зоны через воздух. 5%+ = хорошо, 6%+ = elite scoring.' },
      { key: 'drop_rate', label: 'Drop Rate (%)', format: fmt2, higherBetter: false, help: 'Процент потерянных передач. Надёжность receiving corps. <5% = хорошие руки, <3% = elite hands.' },
      { key: 'pass_rush_ratio', label: 'Pass/Rush Ratio', format: fmt2, higherBetter: null, help: 'Соотношение пасов к выносам. 1.5 = сбалансированно. >2.0 = pass-heavy, <1.2 = run-heavy offense.' },
      { key: 'off_yds_per_game', label: 'Offensive Yards per Game', format: fmt2, higherBetter: true, help: 'Общие ярды нападения за игру. 350+ = хорошо, 400+ = elite offense. Объём производства.' },
      { key: 'punt_avg', label: 'Punt Average (Yards)', format: fmt2, higherBetter: true, help: 'Средняя дальность панта. Сила ноги панкера. 45+ = хорошо, 47+ = elite leg.' },
      { key: 'punt_net_avg', label: 'Punt Net Average (Yards)', format: fmt2, higherBetter: true, help: 'Чистая средняя (с учётом возвратов). Реальное влияние на field position. 40+ = хорошо, 42+ = elite placement.' },
      { key: 'punts_in_20_pct', label: 'Punts Inside 20 (%)', format: fmt2, higherBetter: true, help: 'Процент пантов внутрь 20 ярдов. Точность размещения - coffin corner punting. 40%+ = хорошо, 50%+ = elite.' },
      { key: 'fg_pct', label: 'Field Goal %', format: fmt2, higherBetter: true, help: 'Процент попаданий field goals. Надёжность киккера. 85%+ = хорошо, 90%+ = elite kicker.' },
      { key: 'fg_50plus_pct', label: '50+ Yard FG %', format: fmt2, higherBetter: true, help: 'Процент попаданий с 50+ ярдов. Сила ноги на дальних расстояниях. 50%+ = хорошо, 70%+ = elite range.' },
      { key: 'xp_pct', label: 'Extra Point %', format: fmt2, higherBetter: true, help: 'Процент попаданий extra points. Должно быть 95%+. Ниже = проблемы под давлением или техника.' },
    ];

    async function loadData() {
      const stats = await tryCsv([
        '../output/team_aggregated_stats.csv',
        'output/team_aggregated_stats.csv',
        '/output/team_aggregated_stats.csv'
      ]);

      for (const row of stats) {
        row.logoUrl = (row.logoId !== '' && row.logoId != null) ? 
          `https://cdn.neonsportz.com/teamlogos/256/${row.logoId}.png` : null;
      }

      return stats;
    }

    function drawScatter(holder, rows, metric) {
      const metricKey = metric.key;

      const data = rows.filter(d => 
        Number.isFinite(+d.win_pct) && 
        Number.isFinite(+d[metricKey]) &&
        +d.win_pct >= 0.005 && +d.win_pct <= 0.995
      );

      if (data.length < 2) return;

      const panel = holder.append('details').attr('class', 'panel').attr('open', true);
      const summary = panel.append('summary');
      summary.append('span').text(`${metric.label} vs Win%`);
      
      if (metric.help) {
        const helpIcon = summary.append('span').attr('class', 'help-icon').text('?');
        const metricTip = d3.select('body').append('div').attr('class', 'metric-tooltip').style('display', 'none');
        helpIcon.on('mouseenter', function(evt) {
          metricTip.style('display', 'block').html('<strong>' + metric.label + ':</strong><br>' + metric.help);
        }).on('mousemove', (evt) => {
          metricTip.style('left', (evt.pageX + 12) + 'px').style('top', (evt.pageY - 28) + 'px');
        }).on('mouseleave', () => {
          metricTip.style('display', 'none');
        });
      }

      const margin = { top: 20, right: 24, bottom: 46, left: 70 };
      const width = 1080, height = 480;
      const innerW = width - margin.left - margin.right;
      const innerH = height - margin.top - margin.bottom;

      const wrap = panel.append('div').attr('class', 'chart-wrap');
      const svg = wrap.append('svg').attr('width', width).attr('height', height);
      const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

      const yVals = data.map(d => +d[metricKey]);
      const yMin = d3.min(yVals), yMax = d3.max(yVals);
      const yRange = yMax - yMin;
      const yPad = yRange * 0.15 || 0.5;
      const y = d3.scaleLinear()
        .domain([yMin - yPad, yMax + yPad])
        .range([innerH, 0]);

      const xVals = data.map(d => +d.win_pct);
      const xMin = d3.min(xVals), xMax = d3.max(xVals);
      const xPad = (xMax - xMin) * 0.1 || 0.05;
      const x = d3.scaleLinear()
        .domain([Math.max(0, xMin - xPad), Math.min(1, xMax + xPad)])
        .range([0, innerW]);

      const tickValues = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9].filter(v =>
        v >= x.domain()[0] && v <= x.domain()[1]
      );

      g.append('g').attr('transform', `translate(0,${innerH})`)
        .call(d3.axisBottom(x).tickValues(tickValues).tickFormat(toPct).tickSize(-innerH).tickPadding(8))
        .call(s => s.selectAll('.tick line').attr('stroke', '#e2e2e2'))
        .call(s => s.select('.domain').attr('stroke', '#9aa0a6'));

      const yTickCount = 10;
      g.append('g')
        .call(d3.axisLeft(y).ticks(yTickCount).tickFormat(metric.format).tickSize(-innerW).tickPadding(6))
        .call(s => s.selectAll('.tick line').attr('stroke', '#efefef'))
        .call(s => s.select('.domain').attr('stroke', '#dcdcdc'));

      const yAvg = d3.mean(yVals), xAvg = d3.mean(xVals);
      g.append('line').attr('x1', 0).attr('x2', innerW).attr('y1', y(yAvg)).attr('y2', y(yAvg))
        .attr('stroke', '#999').attr('stroke-dasharray', '6,4').attr('stroke-width', 1.5);
      g.append('line').attr('x1', x(xAvg)).attr('x2', x(xAvg)).attr('y1', 0).attr('y2', innerH)
        .attr('stroke', '#9aa0a6').attr('stroke-dasharray', '6,4').attr('stroke-width', 1.5);
      g.append('text').attr('x', 6).attr('y', y(yAvg)-6).attr('fill', '#555').attr('font-size', 11)
        .text('Avg Y: ' + metric.format(yAvg));
      g.append('text').attr('x', x(xAvg)+6).attr('y', 12).attr('fill', '#555').attr('font-size', 11)
        .text('Avg X: ' + toPct(xAvg));

      const { m, b, r2 } = regression(data.map(d => [+d.win_pct, +d[metricKey]]));
      const xRange = [d3.min(xVals), d3.max(xVals)];
      g.append('line')
        .attr('x1', x(xRange[0])).attr('y1', y(m*xRange[0] + b))
        .attr('x2', x(xRange[1])).attr('y2', y(m*xRange[1] + b))
        .attr('stroke', '#777').attr('stroke-width', 2).attr('opacity', .95);

      const tip = d3.select('body').append('div').attr('class', 'tooltip').style('display', 'none');

      const size = 30;
      const node = g.selectAll('.team').data(data, d => d.team).join('g').attr('class', 'team')
        .attr('transform', d => `translate(${x(d.win_pct)},${y(d[metricKey])})`)
        .on('mouseenter', function(evt, d){
          const trend = m * d.win_pct + b;
          const res = d[metricKey] - trend;
          let html = `<strong>${d.team}</strong><br>`;
          html += `${metric.label}: ${metric.format(d[metricKey])}<br>`;
          html += `Win%: ${toPct(d.win_pct)}<br>`;
          html += `Δ vs trend: ${(res>=0?'+':'') + metric.format(res)}<br>`;
          
          const qx = +d.win_pct >= xAvg;
          const qy = +d[metricKey] >= yAvg;
          let quadrant = '';
          
          if (metric.higherBetter === true) {
            if (qx && qy) quadrant = '<em>✅ Побеждают + хороший показатель метрика</em>';
            else if (!qx && qy) quadrant = '<em>🤔 Хороший метрик, но мало побед - не хватает чего-то ещё</em>';
            else if (!qx && !qy) quadrant = '<em>😔 Проигрывают + слабый метрик - нужны улучшения</em>';
            else quadrant = '<em>💪 Побеждают несмотря на слабый метрик - компенсируют в других зонах</em>';
          } else if (metric.higherBetter === false) {
            if (qx && qy) quadrant = '<em>⚠️ Побеждают несмотря на высокий негативный показатель</em>';
            else if (!qx && qy) quadrant = '<em>😔 Высокий негативный показатель + мало побед - двойная проблема</em>';
            else if (!qx && !qy) quadrant = '<em>🤔 Низкий негатив, но побед мало - проблемы в другом</em>';
            else quadrant = '<em>✅ Низкий негатив + много побед - правильный подход</em>';
          } else {
            if (qx && qy) quadrant = '<em>Правый верхний: высокий Win%, высокий метрик</em>';
            else if (!qx && qy) quadrant = '<em>Левый верхний: низкий Win%, высокий метрик</em>';
            else if (!qx && !qy) quadrant = '<em>Левый нижний: низкий Win%, низкий метрик</em>';
            else quadrant = '<em>Правый нижний: высокий Win%, низкий метрик</em>';
          }
          html += quadrant;
          
          tip.style('display','block').html(html);
        })
        .on('mousemove', (evt)=> tip.style('left', (evt.pageX+12)+'px').style('top',(evt.pageY-28)+'px'))
        .on('mouseleave', ()=> tip.style('display','none'));

      node.append('rect')
        .attr('x', -(size/2 + 2)).attr('y', -(size/2 + 2))
        .attr('width', size + 4).attr('height', size + 4)
        .attr('rx', 4).attr('ry', 4)
        .attr('fill', d => {
          const predicted = m * d.win_pct + b;
          const above = +d[metricKey] >= predicted;
          return (metric.higherBetter !== false && above) || (metric.higherBetter === false && !above) ? 
            'var(--red)' : 'var(--blue)';
        })
        .attr('opacity', .16);

      node.append('image')
        .attr('href', d => d.logoUrl || null)
        .attr('x', -size/2).attr('y', -size/2)
        .attr('width', size).attr('height', size)
        .attr('opacity', .95);

      svg.append('text').attr('x', margin.left + innerW/2).attr('y', height-10)
        .attr('text-anchor', 'middle').attr('fill', '#444').attr('font-size', 12)
        .text('Win Percentage');
      svg.append('text').attr('transform', `translate(14, ${margin.top + innerH/2}) rotate(-90)`)
        .attr('text-anchor', 'middle').attr('fill', '#444').attr('font-size', 12)
        .text(metric.label);

      const legend = panel.append('div').attr('class', 'legend');
      legend.append('span').html(`<span class="swatch red"></span> Better than trend`);
      legend.append('span').html(`<span class="swatch blue"></span> Worse than trend`);
      legend.append('span').html(`<span class="swatch avg"></span> Average Lines`);

      let corrClass = 'corr-weak', corrLabel = 'Weak';
      if (r2 >= 0.5) { corrClass = 'corr-strong'; corrLabel = 'Strong'; }
      else if (r2 >= 0.25) { corrClass = 'corr-moderate'; corrLabel = 'Moderate'; }
      
      summary.append('span').attr('class', `correlation-badge ${corrClass}`)
        .style('margin-left', '12px')
        .html(`R²=${fmt3(r2)} (${corrLabel})`);
    }

    function render() {
      loadData().then(allRows => {
        const root = d3.select('#root');
        
        METRICS.forEach(metric => {
          drawScatter(root, allRows, metric);
        });
      }).catch(err => {
        d3.select('#root').append('div').style('color','crimson').text('Failed to load data: '+err);
        console.error(err);
      });
    }

    window.addEventListener('DOMContentLoaded', render);
  </script>
</head>
<body>
  <div class="container">
    <h1>Team Statistics Explorer — Win% Correlations</h1>
    <div class="subtitle">
      28 comprehensive graphs showing how different team metrics correlate with winning percentage. 
      Red squares = better than expected for their win%, Blue = worse than expected.
      R² shows correlation strength (0=none, 1=perfect).
    </div>
    <div id="root"></div>
    <div class="subtitle">Data: stats_scripts/output/team_aggregated_stats.csv (aggregated from MEGA_*.csv files)</div>
  </div>
</body>
</html>
