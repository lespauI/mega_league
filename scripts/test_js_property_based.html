<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Property-Based NFL Playoff Tests</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
            max-width: 1600px;
            margin: 0 auto;
        }
        .test-result {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            font-size: 12px;
        }
        .test-pass {
            background: #0e4429;
            border-left: 4px solid #26a641;
        }
        .test-fail {
            background: #5a1e1e;
            border-left: 4px solid #f85149;
        }
        .test-critical {
            background: #8b0000;
            border-left: 4px solid #ff0000;
            font-weight: bold;
            padding: 15px;
            font-size: 14px;
        }
        .summary {
            margin: 20px 0;
            padding: 15px;
            background: #2d2d2d;
            border-radius: 4px;
            font-size: 1.2em;
        }
        h1 { color: #58a6ff; }
        h2 { color: #8b949e; margin-top: 30px; }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            background: #252525;
            border-radius: 6px;
        }
        .scenario-details {
            font-size: 11px;
            color: #8b949e;
            margin-left: 20px;
        }
        .invariant-violation {
            background: #ff0000;
            color: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>⚡ Property-Based NFL Playoff Tests</h1>
    <p style="color: #8b949e;">Testing fundamental invariants across 1000+ randomized scenarios</p>
    <div id="results"></div>
    <div id="summary" class="summary"></div>

    <script>
        const teamsInfo = {
            'Cowboys': { division: 'NFC East', conference: 'NFC', logo_url: '' },
            'Giants': { division: 'NFC East', conference: 'NFC', logo_url: '' },
            'Eagles': { division: 'NFC East', conference: 'NFC', logo_url: '' },
            'WFT': { division: 'NFC East', conference: 'NFC', logo_url: '' },
            'Bears': { division: 'NFC North', conference: 'NFC', logo_url: '' },
            'Packers': { division: 'NFC North', conference: 'NFC', logo_url: '' },
            'Vikings': { division: 'NFC North', conference: 'NFC', logo_url: '' },
            'Lions': { division: 'NFC North', conference: 'NFC', logo_url: '' },
            '49ers': { division: 'NFC West', conference: 'NFC', logo_url: '' },
            'Seahawks': { division: 'NFC West', conference: 'NFC', logo_url: '' },
            'Rams': { division: 'NFC West', conference: 'NFC', logo_url: '' },
            'Cardinals': { division: 'NFC West', conference: 'NFC', logo_url: '' },
            'Buccaneers': { division: 'NFC South', conference: 'NFC', logo_url: '' },
            'Saints': { division: 'NFC South', conference: 'NFC', logo_url: '' },
            'Panthers': { division: 'NFC South', conference: 'NFC', logo_url: '' },
            'Falcons': { division: 'NFC South', conference: 'NFC', logo_url: '' }
        };

        let passCount = 0;
        let failCount = 0;
        let criticalFailCount = 0;
        const resultsDiv = document.getElementById('results');

        function logTest(name, passed, message = '', critical = false) {
            const div = document.createElement('div');
            div.className = `test-result test-${passed ? 'pass' : (critical ? 'critical' : 'fail')}`;
            div.textContent = `${passed ? '✓' : '✗'} ${name}${message ? ': ' + message : ''}`;
            resultsDiv.appendChild(div);
            if (passed) {
                passCount++;
            } else {
                failCount++;
                if (critical) criticalFailCount++;
            }
        }

        function logSection(title) {
            const section = document.createElement('div');
            section.className = 'test-section';
            section.innerHTML = `<h2>${title}</h2>`;
            resultsDiv.appendChild(section);
        }

        function logDetails(text) {
            const div = document.createElement('div');
            div.className = 'scenario-details';
            div.textContent = text;
            resultsDiv.appendChild(div);
        }

        // ============================================================
        // CORE TIEBREAKER FUNCTIONS (copy from week18_simulator.py)
        // ============================================================
        
        function breakTwoTeamDivisionTie(teams, stats) {
            const [team1, team2] = teams;
            
            const h2h1 = stats[team1].head_to_head[team2] || { W: 0, L: 0, T: 0 };
            const h2hTotal = h2h1.W + h2h1.L + h2h1.T;
            if (h2hTotal > 0) {
                const h2h1Pct = (h2h1.W + 0.5 * h2h1.T) / h2hTotal;
                const h2h2Pct = (h2h1.L + 0.5 * h2h1.T) / h2hTotal;
                if (h2h1Pct > h2h2Pct) return { winner: team1, tiebreaker: `Head-to-head: won ${h2h1.W}-${h2h1.L}` };
                if (h2h2Pct > h2h1Pct) return { winner: team2, tiebreaker: `Head-to-head: won ${h2h1.L}-${h2h1.W}` };
            }
            
            if (stats[team1].division_pct > stats[team2].division_pct) {
                return { winner: team1, tiebreaker: `Division record: ${stats[team1].division_W}-${stats[team1].division_L}` };
            }
            if (stats[team2].division_pct > stats[team1].division_pct) {
                return { winner: team2, tiebreaker: `Division record: ${stats[team2].division_W}-${stats[team2].division_L}` };
            }
            
            if (stats[team1].conference_pct > stats[team2].conference_pct) {
                return { winner: team1, tiebreaker: `Conference record: ${stats[team1].conference_W}-${stats[team1].conference_L}` };
            }
            if (stats[team2].conference_pct > stats[team1].conference_pct) {
                return { winner: team2, tiebreaker: `Conference record: ${stats[team2].conference_W}-${stats[team2].conference_L}` };
            }
            
            if (stats[team1].strength_of_victory > stats[team2].strength_of_victory) {
                return { winner: team1, tiebreaker: `Strength of victory` };
            }
            if (stats[team2].strength_of_victory > stats[team1].strength_of_victory) {
                return { winner: team2, tiebreaker: `Strength of victory` };
            }
            
            return { winner: team1, tiebreaker: 'Coin toss' };
        }

        function breakTwoTeamWildcardTie(teams, stats) {
            const [team1, team2] = teams;
            
            const h2h1 = stats[team1].head_to_head[team2] || { W: 0, L: 0, T: 0 };
            const h2hTotal = h2h1.W + h2h1.L + h2h1.T;
            if (h2hTotal > 0) {
                const h2h1Pct = (h2h1.W + 0.5 * h2h1.T) / h2hTotal;
                const h2h2Pct = (h2h1.L + 0.5 * h2h1.T) / h2hTotal;
                if (h2h1Pct > h2h2Pct) return { winner: team1, tiebreaker: `Head-to-head: won ${h2h1.W}-${h2h1.L}` };
                if (h2h2Pct > h2h1Pct) return { winner: team2, tiebreaker: `Head-to-head: won ${h2h1.L}-${h2h1.W}` };
            }
            
            if (stats[team1].conference_pct > stats[team2].conference_pct) {
                return { winner: team1, tiebreaker: `Conference record: ${stats[team1].conference_W}-${stats[team1].conference_L}` };
            }
            if (stats[team2].conference_pct > stats[team1].conference_pct) {
                return { winner: team2, tiebreaker: `Conference record: ${stats[team2].conference_W}-${stats[team2].conference_L}` };
            }
            
            if (stats[team1].strength_of_victory > stats[team2].strength_of_victory) {
                return { winner: team1, tiebreaker: `Strength of victory` };
            }
            if (stats[team2].strength_of_victory > stats[team1].strength_of_victory) {
                return { winner: team2, tiebreaker: `Strength of victory` };
            }
            
            return { winner: team1, tiebreaker: 'Coin toss' };
        }

        function applyDivisionTiebreaker(tiedTeams, stats) {
            if (tiedTeams.length === 0) return { ranked: [], tiebreaker: null };
            if (tiedTeams.length === 1) return { ranked: tiedTeams, tiebreaker: null };
            
            if (tiedTeams.length === 2) {
                const result = breakTwoTeamDivisionTie(tiedTeams, stats);
                return { ranked: [result.winner, tiedTeams.find(t => t !== result.winner)], tiebreaker: result.tiebreaker };
            }
            
            return { ranked: tiedTeams, tiebreaker: null };
        }

        function applyWildcardTiebreaker(tiedTeams, stats) {
            if (tiedTeams.length === 0) return { ranked: [], tiebreaker: null };
            if (tiedTeams.length === 1) return { ranked: tiedTeams, tiebreaker: null };
            
            const sameDivision = tiedTeams.every(t => teamsInfo[t].division === teamsInfo[tiedTeams[0]].division);
            if (sameDivision) {
                return applyDivisionTiebreaker(tiedTeams, stats);
            }
            
            if (tiedTeams.length === 2) {
                const result = breakTwoTeamWildcardTie(tiedTeams, stats);
                return { ranked: [result.winner, tiedTeams.find(t => t !== result.winner)], tiebreaker: result.tiebreaker };
            }
            
            return { ranked: tiedTeams, tiebreaker: null };
        }

        function selectWildCards(divisionWinners, allTeams, stats) {
            const divWinnerNames = divisionWinners.map(dw => dw.team);
            const wildCardPool = allTeams.filter(t => !divWinnerNames.includes(t));
            
            wildCardPool.sort((a, b) => {
                if (stats[b].win_pct !== stats[a].win_pct) return stats[b].win_pct - stats[a].win_pct;
                return stats[b].W - stats[a].W;
            });
            
            const wildCards = [];
            let processed = new Set();
            
            for (const team of wildCardPool) {
                if (wildCards.length >= 3) break;
                if (processed.has(team)) continue;
                
                const candidates = wildCardPool.filter(t => 
                    !processed.has(t) && 
                    Math.abs(stats[t].win_pct - stats[team].win_pct) < 0.001
                );
                
                let rankedCandidates, tiebreakerInfo = null;
                if (candidates.length > 1) {
                    const result = applyWildcardTiebreaker(candidates, stats);
                    rankedCandidates = result.ranked;
                    tiebreakerInfo = result.tiebreaker;
                } else {
                    rankedCandidates = candidates;
                }
                
                const spotsRemaining = 3 - wildCards.length;
                const teamsToAdd = rankedCandidates.slice(0, spotsRemaining);
                
                teamsToAdd.forEach(t => {
                    wildCards.push({
                        team: t,
                        record: `${stats[t].W}-${stats[t].L}-${stats[t].T}`,
                        win_pct: stats[t].win_pct,
                        tiebreaker: tiebreakerInfo
                    });
                });
                
                candidates.forEach(t => processed.add(t));
            }
            
            return wildCards;
        }

        // ============================================================
        // RANDOM DATA GENERATION
        // ============================================================
        
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function generateRandomRecord() {
            const wins = randomInt(5, 14);
            const losses = 17 - wins;
            const ties = 0;
            return { W: wins, L: losses, T: ties, win_pct: wins / (wins + losses + ties) };
        }

        function createRandomTeamStats(record = null) {
            const rec = record || generateRandomRecord();
            const divWins = randomInt(0, Math.min(6, rec.W));
            const divLosses = randomInt(0, Math.min(6, rec.L));
            const confWins = randomInt(divWins, rec.W);
            const confLosses = randomInt(divLosses, rec.L);
            
            return {
                W: rec.W,
                L: rec.L,
                T: rec.T,
                win_pct: rec.win_pct,
                division_W: divWins,
                division_L: divLosses,
                division_T: 0,
                division_pct: divWins / (divWins + divLosses || 1),
                conference_W: confWins,
                conference_L: confLosses,
                conference_T: 0,
                conference_pct: confWins / (confWins + confLosses || 1),
                head_to_head: {},
                opponents: [],
                game_results: [],
                defeated_opponents: [],
                strength_of_victory: Math.random() * 0.4 + 0.3,
                strength_of_schedule: Math.random() * 0.4 + 0.3,
                points_for: randomInt(250, 450),
                points_against: randomInt(250, 450),
                conference_points_for: randomInt(150, 250),
                conference_points_against: randomInt(150, 250),
                touchdowns: randomInt(30, 50)
            };
        }

        // ============================================================
        // PROPERTY TESTS
        // ============================================================

        logSection('🔒 CRITICAL INVARIANT: Win Percentage Ordering');

        function test_wild_card_ordering_invariant(iterations = 100) {
            let violations = [];
            
            for (let i = 0; i < iterations; i++) {
                const stats = {};
                const nfcTeams = Object.keys(teamsInfo).filter(t => teamsInfo[t].conference === 'NFC');
                
                // Generate random records
                nfcTeams.forEach(team => {
                    stats[team] = createRandomTeamStats();
                });
                
                // Pick 4 division winners randomly
                const divWinners = [
                    { team: '49ers', record: '13-4' },
                    { team: 'Buccaneers', record: '12-5' },
                    { team: 'Giants', record: '11-6' },
                    { team: 'Packers', record: '11-6' }
                ];
                
                const wildCards = selectWildCards(divWinners, nfcTeams, stats);
                
                // CHECK INVARIANT: Each wild card must have win_pct >= next wild card
                for (let j = 0; j < wildCards.length - 1; j++) {
                    const current = wildCards[j];
                    const next = wildCards[j + 1];
                    
                    if (current.win_pct < next.win_pct - 0.001) {
                        violations.push({
                            iteration: i,
                            current: `${current.team} (${current.record}, ${current.win_pct.toFixed(3)})`,
                            next: `${next.team} (${next.record}, ${next.win_pct.toFixed(3)})`,
                            position: `Seed ${5 + j} → Seed ${5 + j + 1}`
                        });
                    }
                }
            }
            
            const passed = violations.length === 0;
            logTest(
                `Wild card ordering invariant (${iterations} random scenarios)`,
                passed,
                violations.length > 0 ? `${violations.length} VIOLATIONS DETECTED` : '',
                !passed
            );
            
            if (violations.length > 0) {
                violations.slice(0, 5).forEach(v => {
                    logDetails(`Iteration ${v.iteration}: ${v.current} ranked BELOW ${v.next} at ${v.position}`);
                });
                if (violations.length > 5) {
                    logDetails(`... and ${violations.length - 5} more violations`);
                }
            }
            
            return passed;
        }

        function test_no_worse_record_above_better_record(iterations = 200) {
            let violations = [];
            
            for (let i = 0; i < iterations; i++) {
                const stats = {};
                const nfcTeams = Object.keys(teamsInfo).filter(t => teamsInfo[t].conference === 'NFC');
                
                // Generate specific scenario: mix of 10-7, 9-8, 8-9 teams
                const records = [
                    { W: 10, L: 7, T: 0, win_pct: 0.588 },
                    { W: 10, L: 7, T: 0, win_pct: 0.588 },
                    { W: 9, L: 8, T: 0, win_pct: 0.529 },
                    { W: 9, L: 8, T: 0, win_pct: 0.529 },
                    { W: 8, L: 9, T: 0, win_pct: 0.471 },
                    { W: 11, L: 6, T: 0, win_pct: 0.647 },
                ];
                
                const nonDivWinners = nfcTeams.slice(0, 6);
                nonDivWinners.forEach((team, idx) => {
                    stats[team] = createRandomTeamStats(records[idx]);
                });
                
                // Rest get random bad records
                nfcTeams.slice(6).forEach(team => {
                    stats[team] = createRandomTeamStats({ W: randomInt(3, 7), L: randomInt(10, 14), T: 0, win_pct: 0.3 });
                });
                
                const divWinners = [
                    { team: nfcTeams[10], record: '13-4' },
                    { team: nfcTeams[11], record: '12-5' },
                    { team: nfcTeams[12], record: '11-6' },
                    { team: nfcTeams[13], record: '11-6' }
                ];
                
                const wildCards = selectWildCards(divWinners, nfcTeams, stats);
                
                // CHECK: No 9-8 team should appear before any 10-7 team
                const wc_10_7 = wildCards.filter(wc => stats[wc.team].W === 10 && stats[wc.team].L === 7);
                const wc_9_8 = wildCards.filter(wc => stats[wc.team].W === 9 && stats[wc.team].L === 8);
                
                if (wc_10_7.length > 0 && wc_9_8.length > 0) {
                    const idx_10_7 = wildCards.findIndex(wc => stats[wc.team].W === 10);
                    const idx_9_8 = wildCards.findIndex(wc => stats[wc.team].W === 9);
                    
                    if (idx_9_8 < idx_10_7 && idx_9_8 !== -1 && idx_10_7 !== -1) {
                        violations.push({
                            iteration: i,
                            nineeight: wc_9_8[0].team,
                            tenseven: wc_10_7[0].team,
                            order: wildCards.map(wc => `${wc.team} (${wc.record})`).join(' → ')
                        });
                    }
                }
            }
            
            const passed = violations.length === 0;
            logTest(
                `9-8 teams NEVER ranked above 10-7 teams (${iterations} scenarios)`,
                passed,
                violations.length > 0 ? `${violations.length} CRITICAL VIOLATIONS` : '',
                !passed
            );
            
            if (violations.length > 0) {
                violations.slice(0, 3).forEach(v => {
                    logDetails(`Iteration ${v.iteration}: ${v.nineeight} (9-8) BEFORE ${v.tenseven} (10-7)`);
                    logDetails(`  Order: ${v.order}`);
                });
            }
            
            return passed;
        }

        function test_no_duplicates_ever(iterations = 300) {
            let violations = [];
            
            for (let i = 0; i < iterations; i++) {
                const stats = {};
                const nfcTeams = Object.keys(teamsInfo).filter(t => teamsInfo[t].conference === 'NFC');
                
                nfcTeams.forEach(team => {
                    stats[team] = createRandomTeamStats();
                });
                
                const divWinners = [
                    { team: '49ers', record: '13-4' },
                    { team: 'Buccaneers', record: '12-5' },
                    { team: 'Giants', record: '11-6' },
                    { team: 'Packers', record: '11-6' }
                ];
                
                const wildCards = selectWildCards(divWinners, nfcTeams, stats);
                
                const teamNames = wildCards.map(wc => wc.team);
                const uniqueTeams = new Set(teamNames);
                
                if (uniqueTeams.size !== teamNames.length) {
                    const duplicates = teamNames.filter((team, idx) => teamNames.indexOf(team) !== idx);
                    violations.push({
                        iteration: i,
                        duplicates: [...new Set(duplicates)],
                        wildCards: teamNames.join(', ')
                    });
                }
            }
            
            const passed = violations.length === 0;
            logTest(
                `No duplicate teams in wild cards (${iterations} scenarios)`,
                passed,
                violations.length > 0 ? `${violations.length} DUPLICATE VIOLATIONS` : '',
                !passed
            );
            
            if (violations.length > 0) {
                violations.slice(0, 3).forEach(v => {
                    logDetails(`Iteration ${v.iteration}: Duplicates: ${v.duplicates.join(', ')}`);
                    logDetails(`  Wild cards: ${v.wildCards}`);
                });
            }
            
            return passed;
        }

        function test_exactly_three_wild_cards(iterations = 200) {
            let violations = [];
            
            for (let i = 0; i < iterations; i++) {
                const stats = {};
                const nfcTeams = Object.keys(teamsInfo).filter(t => teamsInfo[t].conference === 'NFC');
                
                nfcTeams.forEach(team => {
                    stats[team] = createRandomTeamStats();
                });
                
                const divWinners = [
                    { team: '49ers', record: '13-4' },
                    { team: 'Buccaneers', record: '12-5' },
                    { team: 'Giants', record: '11-6' },
                    { team: 'Packers', record: '11-6' }
                ];
                
                const wildCards = selectWildCards(divWinners, nfcTeams, stats);
                
                if (wildCards.length !== 3) {
                    violations.push({
                        iteration: i,
                        count: wildCards.length,
                        teams: wildCards.map(wc => wc.team).join(', ')
                    });
                }
            }
            
            const passed = violations.length === 0;
            logTest(
                `Exactly 3 wild cards selected (${iterations} scenarios)`,
                passed,
                violations.length > 0 ? `${violations.length} COUNT VIOLATIONS` : '',
                !passed
            );
            
            if (violations.length > 0) {
                violations.slice(0, 3).forEach(v => {
                    logDetails(`Iteration ${v.iteration}: Selected ${v.count} instead of 3: ${v.teams}`);
                });
            }
            
            return passed;
        }

        logSection('🎲 Tiebreaker Consistency Tests');

        function test_tiebreaker_determinism(iterations = 100) {
            let violations = [];
            
            for (let i = 0; i < iterations; i++) {
                const stats = {
                    'Cowboys': createRandomTeamStats({ W: 10, L: 7, T: 0, win_pct: 0.588 }),
                    'Eagles': createRandomTeamStats({ W: 10, L: 7, T: 0, win_pct: 0.588 })
                };
                
                // Run tiebreaker twice
                const result1 = breakTwoTeamWildcardTie(['Cowboys', 'Eagles'], stats);
                const result2 = breakTwoTeamWildcardTie(['Cowboys', 'Eagles'], stats);
                
                if (result1.winner !== result2.winner) {
                    violations.push({
                        iteration: i,
                        first: result1.winner,
                        second: result2.winner
                    });
                }
            }
            
            const passed = violations.length === 0;
            logTest(
                `Tiebreaker determinism (${iterations} scenarios)`,
                passed,
                violations.length > 0 ? `${violations.length} NON-DETERMINISTIC RESULTS` : ''
            );
            
            return passed;
        }

        function test_conference_record_tiebreaker_respected(iterations = 50) {
            let violations = [];
            
            for (let i = 0; i < iterations; i++) {
                const stats = {
                    'Cowboys': createRandomTeamStats({ 
                        W: 10, L: 7, T: 0, win_pct: 0.588,
                    }),
                    'Eagles': createRandomTeamStats({ 
                        W: 10, L: 7, T: 0, win_pct: 0.588,
                    })
                };
                
                // Explicitly set conference records
                stats['Cowboys'].conference_W = 8;
                stats['Cowboys'].conference_L = 4;
                stats['Cowboys'].conference_pct = 0.667;
                
                stats['Eagles'].conference_W = 6;
                stats['Eagles'].conference_L = 6;
                stats['Eagles'].conference_pct = 0.5;
                
                const result = breakTwoTeamWildcardTie(['Cowboys', 'Eagles'], stats);
                
                if (result.winner !== 'Cowboys') {
                    violations.push({
                        iteration: i,
                        winner: result.winner,
                        expected: 'Cowboys',
                        cowboys_conf: '8-4',
                        eagles_conf: '6-6'
                    });
                }
            }
            
            const passed = violations.length === 0;
            logTest(
                `Conference record tiebreaker (8-4 beats 6-6) (${iterations} scenarios)`,
                passed,
                violations.length > 0 ? `${violations.length} TIEBREAKER FAILURES` : ''
            );
            
            return passed;
        }

        logSection('🔥 Stress Tests - Edge Cases');

        function test_all_teams_tied_at_same_record(iterations = 50) {
            let violations = [];
            
            for (let i = 0; i < iterations; i++) {
                const stats = {};
                const teams = ['Cowboys', 'Eagles', 'Seahawks', 'Saints', 'Cardinals'];
                
                teams.forEach(team => {
                    stats[team] = createRandomTeamStats({ W: 10, L: 7, T: 0, win_pct: 0.588 });
                });
                
                const divWinners = [
                    { team: '49ers', record: '13-4' },
                    { team: 'Buccaneers', record: '12-5' },
                    { team: 'Giants', record: '11-6' },
                    { team: 'Packers', record: '11-6' }
                ];
                
                const wildCards = selectWildCards(divWinners, teams.concat(['49ers', 'Buccaneers', 'Giants', 'Packers']), stats);
                
                // All wild cards should be 10-7
                const allCorrectRecord = wildCards.every(wc => stats[wc.team].W === 10 && stats[wc.team].L === 7);
                
                if (!allCorrectRecord) {
                    violations.push({
                        iteration: i,
                        wildCards: wildCards.map(wc => `${wc.team} (${wc.record})`).join(', ')
                    });
                }
            }
            
            const passed = violations.length === 0;
            logTest(
                `All teams at 10-7: all 3 wild cards should be 10-7 (${iterations} scenarios)`,
                passed,
                violations.length > 0 ? `${violations.length} INCORRECT SELECTIONS` : ''
            );
            
            return passed;
        }

        // ============================================================
        // RUN ALL TESTS
        // ============================================================

        console.log('🚀 Running comprehensive property-based tests...');
        const startTime = performance.now();
        
        // CRITICAL INVARIANTS (must pass 100%)
        const inv1 = test_wild_card_ordering_invariant(200);
        const inv2 = test_no_worse_record_above_better_record(300);
        const inv3 = test_no_duplicates_ever(400);
        const inv4 = test_exactly_three_wild_cards(200);
        
        // TIEBREAKER TESTS
        test_tiebreaker_determinism(150);
        test_conference_record_tiebreaker_respected(100);
        
        // EDGE CASES
        test_all_teams_tied_at_same_record(100);
        
        const endTime = performance.now();
        const duration = ((endTime - startTime) / 1000).toFixed(2);

        // Display summary
        const total = passCount + failCount;
        const summaryDiv = document.getElementById('summary');
        
        let summaryHTML = `
            <strong>Property-Based Test Results:</strong><br>
            ${passCount}/${total} tests passed (${((passCount/total)*100).toFixed(1)}%)<br>
            Executed ${total} tests across 1,450 random scenarios in ${duration}s<br>
        `;
        
        if (criticalFailCount > 0) {
            summaryHTML += `<br><div class="invariant-violation">
                ⛔ ${criticalFailCount} CRITICAL INVARIANT VIOLATIONS DETECTED<br>
                DO NOT DEPLOY - FUNDAMENTAL CORRECTNESS ISSUES
            </div>`;
        } else if (failCount > 0) {
            summaryHTML += `<br><span style="color: #f85149;">⚠️ ${failCount} test(s) failed</span>`;
        } else {
            summaryHTML += `<br><span style="color: #26a641;">✅ ALL TESTS PASSED - Safe to deploy</span>`;
        }
        
        summaryDiv.innerHTML = summaryHTML;
        
        console.log(`✅ Tests completed: ${passCount}/${total} passed in ${duration}s`);
        if (criticalFailCount > 0) {
            console.error(`❌ ${criticalFailCount} CRITICAL FAILURES - BLOCKING DEPLOYMENT`);
        }
    </script>
</body>
</html>
